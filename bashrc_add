#!/bin/bash

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

GIT_GIT_PROTOCOL="git://"
GIT_HTTP_PROTOCOL="http://"
GIT_SSH_PROTOCOL="git@"
GIT_SERVER="git.schuerz.at"
GIT_REPO_NAME="server-config.git"
GIT_REPO_PATH_HTTP="/public/"
GIT_REPO_PATH_SSH=":/srv/repos/public/"
GIT_REPO_PATH_GIT="/public/"

GIT_REMOTE_GIT="${GIT_GIT_PROTOCOL}${GIT_SERVER}${GIT_REPO_PATH_GIT}${GIT_REPO_NAME}"
GIT_REMOTE_SSH="${GIT_SSH_PROTOCOL}${GIT_SERVER}${GIT_REPO_PATH_SSH}${GIT_REPO_NAME}"
GIT_REMOTE_HTTP="${GIT_HTTP_PROTOCOL}${GIT_SERVER}${GIT_REPO_PATH_HTTP}${GIT_REPO_NAME}"

GIT_REMOTE_DEFAULT="${GIT_REMOTE_GIT}"

# If GIT_REMOTE is set in ~/.bashrc before sourcing this file, take value from ~/.bashrc
# If set GIT_REMOTE_PROTOCOL in ~/.bashrc before sourcing this file, you cange choose one of the above 
# defined values for a specific host

if [ -z ${GIT_REMOTE+x} ]; then
    case $GIT_REMOTE_PROTOCOL in
        git)
            GIT_REMOTE="${GIT_REMOTE_GIT}"
            ;;
        ssh)
            GIT_REMOTE="${GIT_REMOTE_SSH}"
            ;;
        http)
            GIT_REMOTE="${GIT_REMOTE_HTTP}"
            ;;
        *)
            GIT_REMOTE="${GIT_REMOTE_DEFAULT}"
            ;;
        esac
fi

#GIT_SSH_PATH="/srv/repos"
SERVERCONFIG_SUBPATH=server-config
SERVERCONFIG_BASE="${HOME}/${SERVERCONFIG_SUBPATH}"
SERVERCONFIG_BASH_COMPLETION="${HOME}/${SERVERCONFIG_SUBPATH}/bash_completion.d"
SERVERCONFIG_LOGDIR="${SERVERCONFIG_BASE}/logs"
SERVERCONFIG_LOGFILE="${SERVERCONFIG_LOGDIR}/git.log"
GIT_TIMEOUT=5s

TMUX_SESSION_DIRS=(~/.local/share/tmux/sessions ~/.tmux/sessions)
export SERVERCONFIG_BASE SERVERCONFIG_LOGDIR SERVERCONFIG_LOGFILE TMUX_SESSION_DIRS

#----------------------------------------
# eigentlich sinnloss, denn serverconfig.local könnte man ja direkt in ~/.bashrc vor dem sourcen von bashrc_add einfügen... 
[ -f "${SERVERCONFIG_BASE}/serverconfig.local.conf" ] && . "${SERVERCONFIG_BASE}/serverconfig.local.conf"

sync_config () {
    local nok=""
    local gco=""
    cd  "${SERVERCONFIG_BASE}"
    if which git >/dev/null; then
        echo -n "Sync config with ${GIT_SERVER}: " 1>&2
    	#git pull > /dev/null 2>&1
        # GITCHECKOUT_SCRIPT_OPTIONS are options for bin/git-checkout.sh
        # this are now:
        #   -h for headless repo
        if [ -z ${GITCHECKOUT_SCRIPT_OPTIONS+x} ]; then
            gco="-h"
        else
            gco="$GITCHECKOUT_SCRIPT_OPTIONS"
        fi
        ./bin/git-checkout.sh ${gco}|| nok="not " 1>>"${SERVERCONFIG_LOGFILE}" 2>&1 #|tee -a ./logs/git.log 1>&2   
        printf '%s\n' "${nok}synced" 1>&2

#cat << EOF >&2
#
#---------------------------------------------------
#if you want to update submodules, change dir an run
#cd ~/server-config
#git submodule update --remote --merge
#cd ~
#---------------------------------------------------
#EOF

    else
        echo "git not installed, no configuration possible, please install git" >&2
    	#curl --request GET 'https://git.ebcont.com/jakobus.schuerz/server-config/repository/master/archive.tar.gz'
    fi
    # Install some scripts to ~/bin
    scripts=(configserver.sh git-checkout.sh)
    TARGETDIR="${HOME}/bin"
    [ -d ${TARGETDIR} ] || mkdir -p ${TARGETDIR}
    for i in ${scripts[*]};do
        [ -e bin/${i} ] && install bin/"${i}" "${TARGETDIR}/${i}"
    done

    cd ${HOME}
}




#if $(ping -W 1 -c 1 github.com > /dev/null 2>&1) ;then 
#if [ $(curl -sLI --connect-timeout 1 -m 1 "${GIT_HTTP_PROTOCOL}${GIT_SERVER}" |grep "HTTP/"|tail -n1|cut -d$' ' -f2 ) -eq 200 ] ;then 
case $TERM in
    *term*)
        if [ -d "${SERVERCONFIG_BASE}" ]; then
            cd  "${SERVERCONFIG_BASE}"
            [ -d "${SERVERCONFIG_LOGDIR}" ] || mkdir -p "${SERVERCONFIG_LOGDIR}"
            if [ $(git -C "${SERVERCONFIG_BASE}" rev-parse --git-dir > /dev/null 2>&1 && echo 0 || echo 1 ) ]; then
                echo git
                echo git update
                git remote
                [ $(git remote |grep -v origin) ] && git remote remove origin
                git remote
            
            else
                echo nogit 
                echo git init, fetch, checkout
                git init
            fi
            
            git remote
            git remote add origin "${GIT_REMOTE}"
            git branch --set-upstream-to=origin/master 

            if $( timeout --foreground "${GIT_TIMEOUT}"  git ls-remote >/dev/null  2>&1) ;then 
                sync_config
                . ${SERVERCONFIG_BASE}/functions.sh
                create_symlinks "$SERVERCONFIG_BASE"
            else 
                echo "${GIT_SERVER}" not reachable >&2;
                echo profile not syncing >&2;
            fi
        else
            echo nodir
            echo git clone
            echo "Clone ${SERVERCONFIG_BASE} and configure git"

            git clone "${GIT_REMOTE}" "${SERVERCONFIG_BASE}"

            cd  "${SERVERCONFIG_BASE}"
            [ -d "${SERVERCONFIG_LOGDIR}" ] || mkdir -p "${SERVERCONFIG_LOGDIR}"

            # TODO: set username and fullname to login-users values
            USERNAME="jakobus.schuerz"
            FULLNAME="Jakobus Schürz"
            
            git config user.email ${USERNAME}
            git config user.name ${FULLNAME}

            # Initialize Vundle as preconfigured Submodule
            git submodule update --init --recursive

            sync_config
            . ${SERVERCONFIG_BASE}/functions.sh
            create_symlinks "$SERVERCONFIG_BASE"

            # Install vim Plugins
            #echo "Run Vim, and in Vim run :PluginInstall to install all Plugins"
            vim -c "PluginInstall" -c ":qa!"
        fi


#        if [ $(git -C "${SERVERCONFIG_BASE}" rev-parse --git-dir > /dev/null 2>&1 && echo 0 || echo 1 ) ]; then
#            echo "Update ${SERVERCONFIG_BASE}"
#            cd  "${SERVERCONFIG_BASE}"
#            [ -d "${SERVERCONFIG_LOGDIR}" ] || mkdir -p "${SERVERCONFIG_LOGDIR}"
#            if [ $(git remote | grep -q origin ; echo $?) ] ;then
#                #echo git remote remove origin
#                git remote remove origin
#                #git remote add origin "${GIT_HTTP_PROTOCOL}${GIT_SERVER}:${GIT_HTTP_PATH}${GIT_REPOPATH}"
#                #git remote add origin "${GIT_REMOTE_GIT}"
#                #echo git remote add origin "${GIT_REMOTE}"
#                git remote add origin "${GIT_REMOTE}"
#            else
#                #echo git remote add origin "${GIT_REMOTE}"
#                git remote add origin "${GIT_REMOTE}"
#            fi
#            #git remote set-url --add origin "${GIT_SSH_PROTOCOL}${GIT_SERVER}:${GIT_SSH_PATH}${GIT_REPOPATH}"
##            if [ $( git remote get-url origin|grep -q ${GIT_HTTP_PROTOCOL}${GIT_SERVER} ; echo $?) -gt 0 ]; then
##            fi
#            if $( timeout --foreground "${GIT_TIMEOUT}"  git ls-remote >/dev/null  2>&1) ;then 
#                sync_config
#                . ${SERVERCONFIG_BASE}/functions.sh
#                create_symlinks "$SERVERCONFIG_BASE"
#            else 
#                echo "${GIT_SERVER}" not reachable >&2;
#                echo profile not syncing >&2;
#            fi
#        else
#            echo "Clone ${SERVERCONFIG_BASE} and configure git"
#            #git clone "${GIT_HTTP_PROTOCOL}${GIT_SERVER}${GIT_REPOPATH}" 2>>"${SERVERCONFIG_LOGFILE}"
#            git clone "${GIT_REMOTE}"
#            #git clone "https://github.com/xundeenergie/server-config.git"
#            
#            cd  "${SERVERCONFIG_BASE}"
#            [ -d "${SERVERCONFIG_LOGDIR}" ] || mkdir -p "${SERVERCONFIG_LOGDIR}"
#
#            # Initialize Vundle as preconfigured Submodule
#            git submodule update --init --recursive
#
#            USERNAME="jakobus.schuerz"
#            FULLNAME="Jakobus Schürz"
#            
#            git config user.email ${USERNAME}
#            git config user.name ${FULLNAME}
#
#            #git config push.default simple
#            #git remote set-url origin --add "${GIT_SSH_PROTOCOL}${GIT_SERVER}:${GIT_SSH_PATH}${GIT_REPOPATH}"
#            git remote set-url origin --add "${GIT_REMOTE}"
#            
#            # set upstream for local master
#            git branch -u origin/master
#
#            #git config credential.helper 'store'
#            
#            sync_config
#
#            . ${SERVERCONFIG_BASE}/functions.sh
#            
#            create_symlinks "$SERVERCONFIG_BASE"
#
#            # Install vim Plugins
#            #echo "Run Vim, and in Vim run :PluginInstall to install all Plugins"
#            vim -c "PluginInstall" -c ":qa!"
#        fi
        ;;
    *screen*)
        ;;
esac

. ${SERVERCONFIG_BASE}/functions.sh

######################################################################################
# ls is not in color on all systems
export LS_OPTIONS='--color=auto'
eval "`dircolors`"

#######################################################################################
# User specific aliases and function
if [ -f ~/.bashrc_local ]; then
	. ~/.bashrc_local
fi

if [ -f "${SERVERCONFIG_BASE}/aliases" ]; then
	. "${SERVERCONFIG_BASE}/aliases"
fi

if [ -f ~/.aliases ]; then
	. ~/.aliases
fi

if [ -f "${SERVERCONFIG_BASE}/PS1" ]; then
	. "${SERVERCONFIG_BASE}/PS1"
fi

if [ -f ~/.config/gnome-shell-extensions-default.list ]; then
    gnome-shell-extensions-enable-defaults () { for i in $(cat ~/.config/gnome-shell-extensions-default.list); do gnome-shell-extension-tool -e $i;done; }
fi


#complete -F _ssh sshs
# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
    #PATH="$HOME/bin:$PATH"
    pathmunge "$HOME/bin"
    export PATH
fi


#########################################################################################

[ -z "$XDG_RUNTIME_DIR" ] && export XDG_RUNTIME_DIR=/run/user/$(id -u $USER)
if test $SSH_TTY && test $TERM != screen && test $(systemctl status tmux@${USER}.service 1>/dev/null 2>&1; echo $? ) -eq 0; then
    cat << EOF

        "User: $USER - $UID"

        Starting or resuming screen session
        Press CTRL+C to cancel screen startup

EOF
        #systemctl --user start vnc@5901.service
        sleep 2
        #screen -UxR
        tmux attach-session
fi

unset -f pathmunge
unset -v GIT_REMOTE  GIT_REMOTE_PROTOCOL
cd ${HOME}


PDSH_RCMD_TYPE=ssh

for i in $( ls "${SERVERCONFIG_BASH_COMPLETION}" ); do
    . "${SERVERCONFIG_BASH_COMPLETION}/${i}"
done
